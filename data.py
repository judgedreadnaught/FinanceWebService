import random
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import datetime as dt
from dateutil.relativedelta import relativedelta
from pandas_datareader import data as pdr
import math

yf.pdr_override()
now = dt.date.today()
data = None
starting_dates = ["1D", "1W", "1M", "3M", "6M", "1Y", "5Y"]
std_devs = [2, 1, 3, 4, 5]

smas = [20, 10, 30, 40, 50, 60]  # simple moving averages


def calcDate(date):
    start = now
    if date == "1D":
        start = start - dt.timedelta(days=1)
    elif date == "1W":
        start = start - dt.timedelta(weeks=1)
    elif date == "1M":
        start = start - relativedelta(months=1)
    elif date == "3M":
        start = start - relativedelta(months=3)
    elif date == "6M":
        start = start - relativedelta(months=6)
    elif date == "1Y":
        start = start - relativedelta(years=1)
    elif date == "5Y":
        start = start - relativedelta(years=5)
    return start


def calcSma(stock, date, sma):
    try:
        if (date == "5Y"):
            new_data = pdr.get_data_yahoo(stock, calcDate(date), now)
        else:
            new_data = pdr.get_data_yahoo(stock, now - relativedelta(years=1), now)
        new_data["SMA_" + str(sma)] = round(new_data.iloc[:, 4].rolling(window=sma).mean(), 3)
        st.subheader(str(stock) + " SMA_" + str(sma) + " Data")
        st.write(new_data.iloc[::-1, -1])  # writes the data with today's day as the first index, original data
        # still has reversed rows
        return new_data

    except ValueError:
        st.write("")
    return data


def calcBollinger(data, date, sma):
    if (data is not None):
        std_dev = st.selectbox("Select the Standard Deviation for Bollinger Bands: ", std_devs)
        x = 0
        counter = 0
        bool_data = []
        bool_data_low = []
        for i in data.index:
            if not (str(data.iloc[x, -1]) == "<NA>"):
                num = (round(random.uniform(1, std_dev), 3))
                #st.write("Number Used for Bollinger: " + str(num))
                bool_data.append(float(data.iloc[x, -1]) + (2 * num))  # random num
                # between 1 and the std_dev. The std_dev is usually 2
                # with deep learning, we can find the best value to use for this random number
                # generated by (round(random.uniform(1, std_dev), 3)
                bool_data_low.append(float(data.iloc[x, -1]) - (2 * (round(random.uniform(1, std_dev), 3))))
                # the standard dev is any number
                # between 1 and 2 with a step size of .21
            else:
                bool_data.append("NO DATA")
                bool_data_low.append("NO DATA")
            x = x + 1

        data["Bollinger_Band_Upper"] = bool_data
        data["Bollinger_Band_Lower"] = bool_data_low

        st.subheader("Bollinger Band Data")
        st.write(data.iloc[::-1, -2:])

        chart_data = pd.DataFrame(data[:], columns=["Adj Close", "Bollinger_Band_Upper", "Bollinger_Band_Lower",
                                                    "SMA_" + str(sma)])

        st.subheader("Graph of Bollinger Bands, SMA, and Adjusted Close Price")
        st.line_chart(chart_data)
    return data


def calcPivots(data,stock):  # the data is reversed, the most recent stock data is at the end of the data set
   # prev_high = data.iloc[-1,1]
   # prev_low = data.iloc[-1, 2]
   # prev_close = data.iloc[-1, 3]
    dates = []
    pivots = []
    supports = []
    #st.write(prev_high)
   # st.write(prev_low)
   # st.write(prev_close)
   # pivot = round((float(prev_high) + float(prev_low) + float(prev_close))/3,3)

    counter = 0
    neg_counter = -1
    for i in data.index:
        prev_high = data.iloc[counter,1]
        prev_low = data.iloc[counter,2]
        prev_close = data.iloc[counter,3]
        pivot = round((float(prev_high) + float(prev_low) + float(prev_close)) / 3, 3)
        pivots.append(pivot)
        support = (pivot * 2) - float(prev_high)
        supports.append(support)
        counter = counter + 1
    data["Pivots"] = pivots
    data["Supports"] = supports
    #data["Pivots"].iloc[:, ::-1]
    #st.write(data["Pivots"])
    #st.write(data["Supports"])
    st.subheader("Pivot and Support Points of " + str(stock))
    st.write(data.iloc[::-1,-2:])
    return data

def backTester(data):
    boll_buys = []
    boll_sells = []
    counter = 0
    tracker = 0
    per_change = []
    bought = 0
    date_bought = []
    date_sold = []

    #back_tester_data = pd.DataFrame({"Bollinger Buys":boll_buys}) # -3 == L -4 == U
    for i in data["Bollinger_Band_Upper"].index:
        if(str(data.iloc[counter,-4]) != "nan"):
            bolu_data = float(data.iloc[counter, -4])
            boll_data = float(data.iloc[counter, -3])
            adj_price = float(data.iloc[counter, 4])
            #st.write(str(bolu_data))
            #st.write(str(boll_data))
            #st.write(str(adj_price))
            if (bolu_data < adj_price and bought == 0):
                boll_buys.append(adj_price)
                bought = 1
                #st.write("BOUGHT")
                date_bought.append(str(i.to_pydatetime())[:10])
            elif (boll_data > adj_price and bought == 0):
                boll_buys.append(adj_price)
                bought = 1
                #st.write("BOUGHT")
                date_bought.append(str(i.to_pydatetime())[:10])
            elif (bolu_data > adj_price and bought == 1):
                boll_sells.append(adj_price)
                bought = 0
                #st.write("SOLD")
                date_sold.append(str(i.to_pydatetime())[:10])
            elif (boll_data < adj_price and bought == 1):
                boll_sells.append(adj_price)
                bought = 0
                #st.write("SOLD")
                date_sold.append(str(i.to_pydatetime())[:10])
            elif (len(data["Bollinger_Band_Upper"] < tracker) and bought == 1):
                boll_sells.append(adj_price)
                bought = 0
                #st.write("SOLD")
                date_sold.append(str(i.to_pydatetime())[:10])
            #st.write(data.iloc[counter,-4])
        tracker = tracker + 1
        counter = counter + 1


    filler = 0
    back_tester = pd.DataFrame({"Bollingner Buys": boll_buys})
    #back_tester = pd.DataFrame({"X": boll_sells})
    back_tester.loc[:, "Bollinger Sells"] = boll_sells + [filler] * (len(back_tester.index) - len(boll_sells))
    back_tester["Date Bought"] = date_bought
    back_tester["Date Sold"] = date_sold

#                 profit = round(((selling - buying) / buying) * 100,2)
    # calc the win percentage using first two cols
    counter = 0
    for i in back_tester.index:
        bought = float(back_tester.iloc[counter,0])
        sold = float(back_tester.iloc[counter,1])
        profit = ((sold - bought)/ bought) * 100
        per_change.append(profit)
        counter = counter + 1
    back_tester["Percent Change"] = per_change
    st.title("BACKTESTER")
    st.write(back_tester)

    total_win = 0.0
    counter = 0

    for i in back_tester["Percent Change"].index:
        total_win = float(back_tester.iloc[counter,-1]) + total_win
        counter = counter + 1

    st.subheader("Total Percentage Change is: " + str(round(total_win,3)) + "%")
    # The percent change changes because the bollingers are a random number between 1-2 so

    #new_df.loc[:, "Selling"] = df_selling + [filler] * (len(new_df.index) - len(df_selling))





def app():
    # Intro
    st.title('Pivot Points and Bollinger Bands')
    st.write("This page calculates the Pivot Points and Bollinger Bands of a given stock and stimulates trades using"
             " these metrics.")
    # Getting Stock Info
    stock = st.text_input("Enter Stock Ticker Symbol: ").upper()
    date = st.selectbox("Select Date Range for Stock Data: ", starting_dates)  # 1D,1W,1Y,etc
    sma = st.selectbox("Select the SMA to Use: (20 is the most common) ", smas)
    selected_date = calcDate(date)  # in the format mm/dd/yyyy
    try:
        data = pdr.get_data_yahoo(stock, selected_date, now)
        st.subheader(str(stock) + " Data")
        st.write(data)
        new_data = calcSma(stock, date, sma)
        new_data = calcBollinger(new_data, date, sma)
        new_data = calcPivots(new_data,stock)
        backTester(new_data)
    except ValueError:
        st.write("")
